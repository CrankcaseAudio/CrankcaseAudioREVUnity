// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using CrankcaseAudio.Wrappers;
using UnityEngine;

namespace CrankcaseAudio.Unity
{

    /// <summary>
    /// REV physics simulator.
    /// This is likely a throw away class. You should likely create a REVEnginePlayer and update it with
    /// the physics data coming from your game engine.
    /// </summary>
public class REVPhysicsSimulator : MonoBehaviour
{
    REVPhysicsSimulator()
    {
        State = eState.Paused;
        OutputParams = new PhysicsOutputParameters();
        UpdateParams = new PhysicsUpdateParams();
    }

    public enum eState
    {
        Running,
        Paused
    }
    
    /// <summary>
    /// Gets or sets the current playback state.
    /// </summary>
    /// <value>The state.</value>
    public eState State
    {
        get;
        protected set;
    }

    public void LoadWithPhysicsControlData(VehiclePhysicsControlData controlData)
    {
        this.ControlData = controlData;
        Simulation = new PhysicsSimulation (ControlData);
    }
    
    PhysicsSimulation Simulation
    {
        get;
        set;
    }

    public VehiclePhysicsControlData ControlData
    {
        get;
        private set;
    }
         
    public PhysicsUpdateParams UpdateParams
    {
        get;
        set;
    }
        
    public PhysicsOutputParameters OutputParams
    {
        get;
        private set;
    }
      
    // Use this for initialization
    protected void Start ()
    {
        

    }

    void Update ()
    {
        if (State == eState.Paused)
            return;

        if(Simulation == null)
            return;

        float deltaTime = Time.deltaTime;
        OutputParams = Simulation.Update (UpdateParams, deltaTime);
      
    }

    /// <summary>
    /// Pauses the engine playback state.
    /// </summary>
    public void PauseEngine ()
    {
        State = eState.Paused;
        

    }
    
    /// <summary>
    /// Starts/Resumes the playback state 
    /// </summary>
    public void StartEngine ()
    {
        State = eState.Running;
        
    }

    virtual protected void OnDestroy()
    {
        print("REVPhysicsPlayer was destroyed");

        Simulation = null;

    }

    public class PhysicsUpdateParams
    {
        public float Throttle = 0.0f;
        public float Break = 0.0f;

    };


    public class  PhysicsOutputParameters { 

            public PhysicsOutputParameters()
            {
                Rpm = 0.0f;
                Throttle = 0.0f;
                Gear = 1;
                Velocity = 0.0f;
            }

            public float Rpm; //[0,1]
            public float Throttle; //[0,1]
            public int Gear;//[1,6]
            public float Velocity;//[1, ~150]

        };


private class PhysicsSimulation
    {
        const float KEngineGearRatio = 50.0f;
        const float kWindResistancePerVelocity = 600.0f / 40000.000f;
        const float kFrictionResistance = 1.0f;
        const float KUpShiftingRPM = 0.97f;
        const float KDownShiftRPM = 0.94f;
        const float KThrottleInterpolationTime = 0.050f;

        public PhysicsSimulation(Wrappers.VehiclePhysicsControlData data)
        {
            mVehiclePhysicsControlData = data;
        }

        public PhysicsOutputParameters Update(PhysicsUpdateParams param, float deltaTime)
        {
            mUpdateParams = param;

            mElapsedTime += deltaTime;
            ApplyForces(deltaTime);

            return mPhysicsParams;
        }


        float GetDownShiftRPM(float velocity, int gear)
        {
            //CRANKCASE_ASSERT(gear >= 2);

            float downShiftRPM = 0.0f;

            if (mPhysicsParams.Gear > 1)
                downShiftRPM = velocity * mVehiclePhysicsControlData.GetGearRatio(gear - 2) / KEngineGearRatio;

            return downShiftRPM;
        }

        void ApplyForces(float deltaTime)
        {
            //Normalized
            float normalThrottle = mUpdateParams.Throttle * (1.0f - mUpdateParams.Break);
            float normalBrakeForce = mUpdateParams.Break;

            mPhysicsParams.Throttle = normalThrottle;

            //Forces in Newtons.
            float engineTorque = mVehiclePhysicsControlData.EngineTorque * normalThrottle * mVehiclePhysicsControlData.GetGearRatio(mPhysicsParams.Gear - 1);
            float BrakeingForce = normalBrakeForce * mVehiclePhysicsControlData.BreakingHorsePower;
            float windResistance = kWindResistancePerVelocity * mPhysicsParams.Velocity * mPhysicsParams.Velocity;
            float frictionResistance = kFrictionResistance * mVehiclePhysicsControlData.Weight;

            float netForce = engineTorque - BrakeingForce - windResistance - frictionResistance;


            //Change in Velocity;
            float velocity = mPhysicsParams.Velocity + (netForce / mVehiclePhysicsControlData.Weight) * deltaTime;

            if (velocity < 0.0f)
                velocity = 0.0f;

            //Now working backwords, what is the engine RPM as a results of this velocity and gear ratio.
            float rpm = velocity * mVehiclePhysicsControlData.GetGearRatio(mPhysicsParams.Gear - 1) / KEngineGearRatio;


            //Now determine if we need to shift.
            if (rpm > KUpShiftingRPM && mPhysicsParams.Gear != 5)
            {
                mPhysicsParams.Gear = mPhysicsParams.Gear + 1;
                rpm = velocity * mVehiclePhysicsControlData.GetGearRatio(mPhysicsParams.Gear - 1) / KEngineGearRatio;

            }
            //If the RPM that we'd be at if we downshift is below KDownShiftRPM, then it makes sense to downshift.
            if (mPhysicsParams.Gear >= 2 && KDownShiftRPM > GetDownShiftRPM(velocity, mPhysicsParams.Gear))
            {
                mPhysicsParams.Gear = mPhysicsParams.Gear - 1;
                rpm = velocity * mVehiclePhysicsControlData.GetGearRatio(mPhysicsParams.Gear - 1) / KEngineGearRatio;
            }

            if (rpm > 1.0f && mPhysicsParams.Gear == 5)
            {
                //Max speed. Do not change anything.
            }
            else
            {
                mPhysicsParams.Velocity = velocity;
                mPhysicsParams.Rpm = rpm;
            }
        }

        private PhysicsUpdateParams mUpdateParams;
        private PhysicsOutputParameters mPhysicsParams = new PhysicsOutputParameters();
        private VehiclePhysicsControlData mVehiclePhysicsControlData;
        float mElapsedTime;


    }

    }


}

